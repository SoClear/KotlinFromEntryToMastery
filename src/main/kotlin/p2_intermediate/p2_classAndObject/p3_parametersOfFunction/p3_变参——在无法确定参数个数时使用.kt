package p2_intermediate.p2_classAndObject.p3_parametersOfFunction

/*
有时我们无法确定在调用函数时需要传递多少个参数。
针对这种情况，Kotlin 也和Java一样提供了可变长参数(简称“变参”)来解决该问题。
在Kotlin中使用变参，只需要在声明的参数名前加上关键字vararg即可，
但是每个函数只能拥有一个变参。
*/

/*
1.单独使用变参
*/
//[举例]声明一个累加函数，该函数可以接受任意个参数，并将这些参数的值进行累加后返回。具体代码如下:
// n为变参，即n的个数不固定
fun sum(vararg n: Int):Int {
    var result = 0
    for (a in n) {
        result += a
    }
    return result
}
/*
接下来调用该函数，具体代码如下:
// 0个参数，输出0
println (sum())
// 1个参数，输出1
printIn (sum(1) )
/12个参数，输出3
println(sum(1，2))
// 5个参数，输出15
println(sum(1, 2, 3, 4, 5))
从这个例子中可以看到，
变参有以下几个特点:
变参底层是通过数组类型进行传递的。
变参除可以接受多个参数外， 也可以接受0个参数。
*/

/*
2.混合使用变参和普通参数
在上面代码中，sum()函数的参数列表中只包含了一个变参。
我们再看个在参数列表中同时存在普通参数和变参的例子，具体代码如下:
*/
//第1个参数为整型(普通参数)，第2个参数为整型变参
fun sum1(init:Int, vararg n: Int) : Int {
    return n.sum() + init
}
//调用函数
//初始值为100
//sum1(100，1，2，3)
/*
这段代码最终运行正常并输出了结果，所以我们可以知道:
如果将变参放在参数列表的最后一位是不会对函数调用造成任何影响的。
那如果将变参放在其他位置呢?在Java中是不允许出现这种情况的，而Kotlin虽然允许这
样操作，但是此时变参后的参数都应该使用命名参数进行调用，这样才能确保实参被正确地
绑定。
*/
//[举例]创建1个变参为第1个参数的函数sum2(),并调用该函数。具体代码如下:
fun sum2(vararg n:Int,init:Int):Int{
    return n.sum()+init
}
//调用函数
//sum(1,2,3,init=5)

/*
变参是通过数组来实现的，那么我们很容易想到:在调用函数时可以直接将整个数组绑到变参上。
但如果只是单纯传递数组，编译器不知道是应该将这个数组作为变参来处理，还是作为变参的第1个元素来处理。
为了处理这种情况，Kotlin 规定:数组默认会作为变参的第1个参数进行传递，
而如果用*号作为前缀来修饰参数名，则数组会整体被绑定到变参上，具体码如下:
 */
fun main() {
    println(sum())
    println(sum(1,2))
    println(sum(1,2,3,4,5))

    println(sum1(1,2))
    println(sum2(1,2,init = 3))

    val intArray= intArrayOf(1,2,3)
    //直接将数组类型绑定到变参上
    sum(*intArray)
}

